#!/usr/bin/env python3
"""
plot_block_metrics.py
---------------------
Reads a Parquet file containing per-block comparison metrics (generated by
compare_maps.py) and creates map visualizations for specified metrics.

Each map shows the geographic distribution of a metric across the processing blocks.
"""

import argparse
import logging
from pathlib import Path
import warnings
import textwrap # For wrapping long descriptions

import geopandas as gpd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from mpl_toolkits.axes_grid1 import make_axes_locatable # For colorbar placement

# --- Configuration & Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
logger = logging.getLogger("plot_block_metrics")

DEFAULT_DPI = 300
DEFAULT_CMAP = 'viridis'

# --- Metric Descriptions --- 
METRIC_DESCRIPTIONS = {
    "oa_2x2": "Overall accuracy comparing Custom {class1} vs Ref {ref_class1} and Custom {class2} vs Ref {ref_class2}\
              only where both maps agree the pixel is forest.",
    "kappa_2x2": "Kappa coefficient comparing Custom {class1} vs Ref {ref_class1} and Custom {class2} vs Ref {ref_class2}\
                 only where both maps agree the pixel is forest.",
    "perc_custom_only_forest": "Percentage of comparable pixels classified as forest ONLY by the custom map ({class1} or {class2}).",
    "perc_ref_only_forest": "Percentage of comparable pixels classified as forest ONLY by the reference map ({ref_class1} or {ref_class2}, {ref_type}).",
    "perc_both_forest": "Percentage of comparable pixels classified as forest by BOTH maps.",
    "perc_both_nonforest": "Percentage of comparable pixels classified as non-forest by BOTH maps.",
}

REF_CLASS_NAMES = {
    'DLT': {1: 'Broadleaved', 2: 'Coniferous'},
    'BDForet': {1: 'Deciduous', 2: 'Evergreen'}
}
CUSTOM_CLASS_NAMES = {1: 'Deciduous', 2: 'Evergreen'}

def get_metric_description(metric_name, ref_type):
    """Gets a description for a given metric name, incorporating ref_type."""
    
    ref_names = REF_CLASS_NAMES.get(ref_type, {1: 'RefClass1', 2: 'RefClass2'})
    custom_names = CUSTOM_CLASS_NAMES
    
    if metric_name in METRIC_DESCRIPTIONS:
        desc = METRIC_DESCRIPTIONS[metric_name]
        try:
            desc = desc.format(
                ref_type=ref_type,
                class1=custom_names[1],
                class2=custom_names[2],
                ref_class1=ref_names[1],
                ref_class2=ref_names[2]
            )
        except KeyError as e:
            logger.warning(f"Failed to format description for {metric_name}, missing key: {e}")
        return desc
    
    parts = metric_name.split('_')
    base_metric = parts[0]
    if base_metric in ['f1', 'precision', 'recall'] and len(parts) > 1:
        class_name = ''.join(parts[1:])
        custom_class_label = class_name
        ref_class_label = "Unknown"
        if class_name == custom_names[1]:
            ref_class_label = ref_names[1]
        elif class_name == custom_names[2]:
            ref_class_label = ref_names[2]
            
        comparison_text = f"Custom '{custom_class_label}' vs Ref '{ref_class_label}' ({ref_type})"
        
        metric_type = {
            'f1': "F1-score",
            'precision': "Precision",
            'recall': "Recall"
        }.get(base_metric, base_metric.title())
            
        return f"{metric_type} for class '{custom_class_label}' ({comparison_text}) within the 2x2 forest comparison."
            
    return "" # Default empty description

def plot_metric_map(gdf, metric_column, output_path, title, description, cmap=DEFAULT_CMAP, dpi=DEFAULT_DPI):
    """Creates and saves a map visualization for a given metric column."""
    
    if metric_column not in gdf.columns:
        logger.error(f"Metric column '{metric_column}' not found. Skipping.")
        return
        
    if gdf[metric_column].isnull().all():
        logger.warning(f"Metric column '{metric_column}' contains only NaN values. Skipping plot.")
        return
        
    fig, ax = plt.subplots(1, 1, figsize=(10, 11)) # Slightly taller figure for description

    vmin = gdf[metric_column].min()
    vmax = gdf[metric_column].max()
    
    # Determine if data is percentage for label formatting
    is_percentage = metric_column.startswith('perc_')

    # Plot without the default legend
    gdf.plot(column=metric_column, 
             ax=ax, 
             cmap=cmap,
             linewidth=0.5, 
             edgecolor='black',
             legend=False, # Disable default legend
             missing_kwds={ 
                 "color": "none",
                 "edgecolor": "none",
             },
             vmin=vmin, 
             vmax=vmax)

    # Clean up the plot axes
    ax.set_axis_off()
    ax.set_title(title, fontsize=16, pad=5) # Reduce title padding slightly

    # Add description below the title
    if description:
        wrapped_desc = textwrap.fill(description, width=90) # Adjust width
        # Use figure coordinates for positioning relative to the whole figure
        fig.text(0.5, 0.92, wrapped_desc, # Adjust y position (0.9 = top, 0 = bottom)
                 ha='center', va='top', 
                 fontsize=10, color='#555555')
                 
    # Manually create colorbar with min/max ticks
    norm = mcolors.Normalize(vmin=vmin, vmax=vmax)
    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm._A = [] # Fake up the array of the scalar mappable - needed for colorbar
    
    # Create an axes for the colorbar
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("bottom", size="5%", pad=0.1)
    
    cb = fig.colorbar(sm, cax=cax, orientation='horizontal')
    
    # Set ticks to min and max
    cb.set_ticks([vmin, vmax])
    
    # Format tick labels
    if is_percentage:
        cb.set_ticklabels([f"{vmin:.1f}%", f"{vmax:.1f}%"])
    else:
        cb.set_ticklabels([f"{vmin:.2f}", f"{vmax:.2f}"]) # Format decimals
        
    cb.set_label(metric_column.replace('_', ' ').title()) # Add label to colorbar

    # Adjust layout to prevent overlap - may need further tweaking
    # fig.tight_layout(rect=[0, 0.03, 1, 0.93]) # Adjust bottom/top spacing

    # Save the figure
    logger.info(f"Saving map for '{metric_column}' to {output_path}")
    try:
        # Use bbox_inches='tight' which often helps with layout issues
        fig.savefig(output_path, dpi=dpi, bbox_inches='tight', pad_inches=0.1)
    except Exception as e:
        logger.error(f"Failed to save figure {output_path}: {e}")
        
    plt.close(fig)

def main():
    parser = argparse.ArgumentParser(
        description="Generate map visualizations for per-block metrics from a Parquet file.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("--input-parquet", type=str, required=True,
                        help="Path to the input Parquet file (output of compare_maps.py).")
    parser.add_argument("--output-dir", type=str, required=True,
                        help="Directory to save the generated map images.")
    parser.add_argument("--metrics", type=str, nargs='+', required=True,
                        help=f"List of metric column names to plot (e.g., oa_2x2 f1_Deciduous).")
    parser.add_argument("--ref-type", type=str, required=True, choices=['DLT', 'BDForet'], # Added ref-type arg
                        help="Specify the reference map type used in the comparison (DLT or BDForet) for context.")
    parser.add_argument("--cmap", type=str, default=DEFAULT_CMAP,
                        help="Matplotlib colormap name to use for the plots.")
    parser.add_argument("--dpi", type=int, default=DEFAULT_DPI,
                        help="Resolution (dots per inch) for saving PNG images.")
    parser.add_argument("--filename-prefix", type=str, default="map",
                        help="Prefix for the output map filenames.")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enable debug logging.")

    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug logging enabled.")

    input_path = Path(args.input_parquet)
    output_dir = Path(args.output_dir)

    # Validate input file
    if not input_path.is_file():
        logger.error(f"Input Parquet file not found: {input_path}")
        return

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Read the GeoDataFrame
    logger.info(f"Reading GeoDataFrame from: {input_path}")
    try:
        gdf = gpd.read_parquet(input_path)
        logger.info(f"Successfully read {len(gdf)} blocks with CRS: {gdf.crs}")
    except Exception as e:
        logger.error(f"Failed to read Parquet file {input_path}: {e}")
        return

    # Plot each specified metric
    for metric in args.metrics:
        # Add ref_type to the output filename
        output_filename = f"{args.filename_prefix}_{metric}_{args.ref_type}.png"
        output_filepath = output_dir / output_filename
        plot_title = f"Map of {metric.replace('_', ' ').title()}"
        metric_desc = get_metric_description(metric, args.ref_type)
        
        plot_metric_map(gdf, metric, output_filepath, plot_title, metric_desc, cmap=args.cmap, dpi=args.dpi)

    logger.info("Finished generating maps.")

if __name__ == "__main__":
    main() 